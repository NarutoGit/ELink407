# 独立看门狗实验 #

按下 K1 按键,通过使得无法执行喂狗程序，从而造成系统复位。

## 实验原理与基础知识 ##

嵌入式系统常常会工作在复杂的环境中，因此会受到来自电磁场，振动，温湿度等外部环境的干扰，造成各种寄存器和内存的数据混乱，会导致程序指针错误，不在程序区，取出错误的程序指令等，都会陷入死循环，程序的正常运行被打断，设备工作不正常，会造成整个系统的陷入停滞状态，发生不可预料的后果，为了实现无人值守状态下设备连续正常工作，于是看门狗机制孕育而生。

看门狗的原理在系统运行以后也就启动了看门狗的计数器，看门狗就开始自动计数，正常运行程序中会有一段喂狗的代码，如果到了一定的时间还没有喂狗，说明代码已经跑离轨道，那么看门狗计数器就会溢出从而引起看门狗中断，系统复位。

STM32F4xx 内置两个看门狗，独立看门狗和窗口看门狗（下一章节讲解），独立看门狗(IWDG)由专用的低速时钟(LSI)驱动，即使主时钟发生故障它也仍然有效。独立看门狗的时钟是一个内部 RC 时钟，所以并不是准确的 32Khz，而是在 15~47Khz 之间的一个可变化的时钟，只是我们在估算的时候，以 32Khz 的频率来计算，所以它适合应用于那些需要看门狗作为一个在主程序之外，能够完全独立工作，并且对时间精度要求较低的场合。独立看门狗的功能框图

![](img/chapter14/1.1.1.png) 

独立看门狗寄存器

    关键字寄存器(IWDG_KR)     Key register
    
    偏移地址：0x00
      
![](img/chapter14/1.1.2.png) 
    
    预分频器寄存器(IWDG_PR)    Prescaler register
    
    偏移地址：0x04
    
![](img/chapter14/1.1.3.png) 

    重载寄存器(IWDG_RLR)      Reload register
    
    偏移地址：0x08
    
![](img/chapter14/1.1.4.png) 

    状态寄存器(IWDG_SR)       Status register
    
    偏移地址：0x0C
    
![](img/chapter14/1.1.5.png) 
    
    
## 电路设计 ##


## 库函数和数据结构 ##
独立看门狗相关的库函数操作函数在文件 stm32f4xx_iwdg.c 和对应的头文件 stm32f4xx_iwdg.h 中

        IWDG_WriteAccessCmd(IWDG_WriteAccess_Enable);
        
取消寄存器写保护函数,向 IWDG_KR 写入 0X5555

        void IWDG_SetPrescaler(uint8_t IWDG_Prescaler);   
        
设置看门狗的分频系数的函数

        void IWDG_SetReload(uint16_t Reload);
        
设置看门狗的重装载值的函数

        IWDG_ReloadCounter(); 
        
重载计数值喂狗函数，向 IWDG_KR 写入 0XAAAA

        IWDG_Enable();  
        
启动看门狗函数 向 IWDG_KR 写入 0XCCCC

## 软件设计、开发 ##

在工程中添加iwdg.c文件和iwdg.h 文件，所有 IWDG 相关的驱动代码和定义都在这两个文件中。

iwdg.c文件代码如下：

iwdg.h代码如下：

main.c测试代码如下：

## 软件下载、测试验证 ##


