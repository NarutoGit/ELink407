# STM32F407 的存储器模型 #

## 存储器空间映射 ##

Cortex-M4是32位的内核，因此其PC指针可以指向2^32=4G的地址空间，也就是0x0000_0000——0xFFFF_FFFF这一大块空间。程序存储器、数据存储器、寄存器和I/O 端口排列在同一个顺序的4 GB 地址空间内。

![](img/chapter03/1.1.0.png) 

Cortex-M4内核的设计导致了，使用该内核的设计者必须按照这个进行各自芯片的存储器结构设计。这就可以去了解STM32的存储器结构，以及为什么这样设计STM32存储器的结构了。

Cortex-M4是一个内核，自身定义了一个存储器结构，ST公司按照Cortex-M4的这个存储器定义，设计出了自己的存储器结构；但是ST公司的STM32的存储器结构必须按照Cortex-M4这个定义的存储器结构来进行设计。Cortex-M4内核通过I-Code、D-Code、System总线与STM32内部的Flash、SROM相连接的，该种连接情况直接关系到STM32存储器的结构组织；也就是说，Cortex-M4的存储器结构决定了STM32的存储器结构存储器映射是指把芯片中或芯片外的FLASH，RAM，外设，BOOTBLOCK等进行统一编址。即用地址来表示对象。这个地址绝大多数是由厂家规定好的，用户只能用而不能改。用户只能在挂外部RAM或FLASH的情况下可进行自定义

首先，我们对比一下Cortex-M4存储器结构和STM32存储器结构：

![](img/chapter03/1.1.1.png) 

图中可以很清晰的看到，STM32的存储器结构和Cortex-M4的很相似，不同的是，STM32加入了很多实际的东西，如：Flash、SRAM等。只有加入了这些东西，才能成为一个拥有实际意义的、可以工作的处理芯片——STM32。

Peripherals：外设的存储器映射，对该区域操作，就是对相应的外设进行操作；

SRAM：运行时临时存放代码的地方；
                                                                                            
Flash：存放代码的地方；

System Memory：STM32出厂时自带的你只能使用，不能写或擦除；

Option Bytes：可以按照用户的需要进行配置（如配置看门狗为硬件实现还是软件实现）；

对STM32存储器知识的掌握，实际上就是对Flash和SRAM这两个区域知识的掌握。因此，下面将重点描述Flash和SRAM的知识。

### STM32的SRAM ###

SRAM的理解比较简单，其作用是用来存取各种动态的输入输出数据、中间计算结果以及与外部存储器交换的数据和暂存数据。设备断电后，SRAM中存储的数据就会丢失。   

不同类型的STM32单片机的SRAM大小是不一样的，但是他们的起始地址都是0x2000 0000，终止地址都是0x2000 0000+其固定的容量大小。  STM32F407带有4 KB 备份SRAM和192 KB 系统SRAM。系统SRAM 可按字节、半字（16 位）或全字（32 位）访问。读写操作以CPU 速度执行，且等待周期为0。系统SRAM 分为三个块：   
  
● 映射在地址0x2000 0000 的112 KB 和16 KB 块，可供所有AHB 主控总线访问。  

● 映射在地址0x2002 0000 的64 KB 块，可供所有AHB 主控总线访问。AHB 主总线支持并发SRAM 访问（通过以太网或  USB OTG HS）：例如，当CPU 对112 KB 或64 KB SRAM 进行读/写操作时，以太网 MAC 可以同时对16 KB SRAM 进行读/写操作。   

● 在地址0x1000 0000 映射的64 KB 块，只能供CPU 通过数据总线访问。  

### STM32的Flash ###

STM32的Flash，严格说，应该是Flash模块。Flash 模块可管理CPU 通过AHB I-Code 和D-Code 对Flash 进行的访问。该接口可针对Flash 执行擦除和编程操作，并实施读写保护机制。Flash 接口通过指令预取和缓存机制加速代码执行。 

STM32F4 的闪存模块由：主存储器、系统存储器、OPT 区域和选项字节等 4 部分组成，四个组成部分分别在0x0000 0000——0xFFFF FFFF不同的区域，如图所示：

![](img/chapter03/1.1.2.png) 

主存储器，该部分用来存放代码和数据常数（如 const 类型的数据）。分为 12 个扇区，前 4个扇区为 16KB 大小，然后扇区 4 是 64KB 大小，扇区 5~11 是 128K 大小，不同容量的 STM32F4，拥有的扇区数不一样，比如我们的STM32F407VGT6，则拥有全部 12 个扇区。
从上图可以看出主存储器的起始地址就是 0X08000000，  B0、B1 都接 GND 的时候，就是从 0X08000000 开始运行代码的。

系统存储器，这个主要用来存放 STM32F4 的 bootloader 代码，此代码是出厂的时候就固化在 STM32F4 里面了，专门来给主存储器下载代码的。当 B0 接 V3.3，B1 接 GND 的时候，从该存储器启动（即进入串口下载模式）。

OTP 区域，即一次性可编程区域，共 528 字节，被分成两个部分，前面 512 字节（32 字节为 1 块，分成 16 块），可以用来存储一些用户数据（一次性的，写完一次，永远不可以擦除！！），后面 16 字节，用于锁定对应块。

选项字节，用于配置读保护、BOR 级别、软件/硬件看门狗以及器件处于待机或停止模式下的复位。

## 位带区 ##
玩过51的都知道51里面是有位操作，以一位（BIT）为数据对象的操作，以简单的将P1口的第2位独立操作： 

        P1.2=0;
        P1.2=1;
    
这样就把P1口的第三个脚（BIT2）置0置1。  

那么在STM32里面怎么实现位操作呢？通常我们通过读－改－写三个步骤来操作，先将需要修改地址的字读到变量中，修改变量相应的bit位，再写回地址中，C语言的操作代码如下：

       typedef unsigned  int 		uint32_t;

       #define     __IO    volatile 
            
       #define GPIOA_MODER (*((__IO uint32_t *)0x40020000))
          
	   MODER|=1<<(8*2);    		//设置 PA8 为输出模式
       
c代码通过反汇编可以简化下面3条汇编语句：
       
       LDR           r0,[0x40020000]  
       ORR           r0,r0,#0x10000
       STR           r0,[0x40020000]        

通过跟51对位操作的对比，我们发现，上面对位操作指令多，并且非原子操作有可能被中断打断，那么怎么来实现类似于单片机代码缩小， 速度更快，效率更高，更安全位操作呢，STM32的位段、位带别名区就为了实现这样的功能。

它的对象可以是SRAM、I/O和外设空间。要实现对这些地方的某一位的操作。它是这样做的：在寻址空间（32位对应的地址空间为 4GB ）的另一地方，取个别名区空间，从这个地址开始处，每一个字（32BIT）对应SRAM或I/O的一位。这样，1MB SRAM 就可以有 32MB 的对应别名区空间，就是1位膨胀到32位（1 BIT 变为1个字节）。我们对这个别名区空间内的某一字操作（置0或置1），就等于它映射的 SRAM 或 I/O 相应的某地址的某一位的操作。

Cortex™-M4F 存储器映射包括两个位段区域。这些区域将存储器别名区域中的每个字映射到存储器位段区域中的相应位。在别名区域写入字时，相当于对位段区域的目标位执行读-修改-写操作。

在STM32F4xx 器件中，外设寄存器和SRAM 均映射到一个位段区域，这样可实现单个位段的读写操作。这些操作仅适用于Cortex™-M4F 访问，对于其它总线主接口（如DMA）无效。可通过一个映射公式说明别名区域中的每个字与位段区域中各个位之间的对应关系。映射公式为：

        bit_word_addr= bit_band_base+ (byte_offsetx 32) + (bit_number× 4)

其中：
        — bit_word_addr 代表别名区域中将映射到目标位的字的地址
        — bit_band_base 代表别名区域的起始地址
        — byte_offset 代表目标位所在位段区域中的字节编号
        — bit_number 代表目标位的位位置(0-7)
    示例
    
下例说明如何将SRAM 地址0x20000300 处字节的位2 映射到别名区域：

        0x22006008 = 0x22000000 + (0x300*32) + (2*4)

对地址0x22006008 执行写操作相当于在SRAM 地址0x20000300 处字节的位2 执行读-修 改-写操作。

对地址0x22006008 执行读操作将返回SRAM 地址0x20000300 处字节的位2 的值（0x01表示位置位，0x00 表示位复位）。

## 不同启动模式对应的内存映射 ##

存储器采用固定的存储器映射，代码区域起始地址为0x0000 0000，而数据区域起始地址为0x2000 0000。Cortex™-M4F CPU 复位后PC的起始地址始终为0x0000 0000,并通过ICode 总线获取复位向量，这意味着只有代码区域。STM32F4xx 微控制器实施一种特殊机制，可将代码区域（如内部SRAM） 进行启动。首先系统上电或复位后，在SYSCLK 的第四个上升沿锁存BOOT 引脚的值。所以用户可以通过设置BOOT1 和BOOT0 引脚来选择需要的启动模式。

在STM32F4xx 中，可通过`BOOT[1:0]` 引脚选择三种不同的自举模式，如表所示。

![](img/chapter0/boot.png) 

BOOT0 为专用引脚，而BOOT1 则与GPIO 引脚共用。一旦完成对BOOT1 的采样，相应GPIO 引脚即进入空闲状态，可用于其它用途。器件退出待机模式时，还会对BOOT 引脚重新采样。因此，当器件处于待机模式时，这些引脚必须保持所需的自举模式配置。这样的启动延迟结束后，CPU 将从地址0x0000 0000 获取栈顶值，然后从始于0x0000 0004 的自举存储器开始执行代码。

选择自举引脚后，应用程序软件可以将某些存储器设定为从代码空间进行访问（这样，可通过ICode 总线而非系统总线执行代码）。这样的修改通过在SYSCFG 控制器中编程SYSCFG 存储器重映射寄存器(SYSCFG_MEMRMP) 来实现。

SYSCFG 存储器重映射寄存器(SYSCFG_MEMRMP) SYSCFG memory remap register
偏移地址：0x00

![](img/chapter0/boot.png) 

此寄存器用于对存储器重映射进行配置：   

● 使用两个位来配置可在地址0x0000 0000 访问的存储器区域。从而通过软件选择物理重映射，而旁路BOOT 引脚。   

● 这两个位的复位值和复位时BOOT 引脚的设置相同。当BOOT 引脚设为10 `[(BOOT1,BOOT0) = (1,0)] `从主Flash 中自举时，寄存器值为0x00。当把FSMC 重映射到地址0x0000 0000 时，只有FSMC 的Bank1 的前两个区域（NOR/PSRAM 1和NOR/PSRAM 2）可被重映射到低端地址。在重映射模式下，CPU 可以通过ICode 总 线 （而不是System 总线）访问外部存储器来提高性能。  


## 端格式 ##

STM32F407 各字节按小端格式在存储器中编码。字中编号最低的字节被视为该字的最低有效字节，而编号最高的字节被视为最高有效字节。

![](img/chapter03/1.3.1.png) 
  
上图所示的是小端存储方式。
